module Thirteen where

-- For reading data in nicely
import Text.ParserCombinators.ReadP 
import Data.Char 
import Data.Coerce
import Control.Monad
import Control.Arrow (first, second)
import Data.Function (on, (&))
import Data.List 
import Data.Functor ((<&>))
import Data.Maybe
import Data.Map (Map)
import qualified Data.Map as Map
import Debug.Trace


main = do
    -- Data loading
    tree <- readFile "input"
         <&> (readTrack)

    -- Part 1
    print tree

    -- Part 2
    return ()
                            

update :: Track -> Either (Int,Int) Track
update t@(Track railMap carts) = Track railMap <$> fst <$> updateCarts [] carts 
    where updateCarts :: [CartMeta] -> [CartMeta] -> Either (Int,Int) [CartMeta]
          updateCarts dones [] = Right dones
          updateCarts dones (c:cs) = let
                move :: CartMeta -> CartMeta
                move ((y,x),dir,intention) = ((y',x'),dir',intention')
                        where
                            (y',x') = case dir of
                                W -> (y,x-1)
                                E -> (y,x+1)
                                S -> (y+1,x)
                                N -> (y+1,x)
                c' = move c
                
        

-- *** Data types and marshalling functions ***
data Track = Track Railmap [CartMeta]

type CartMeta = ((Int,Int), Cart, Intention)

type Map2D a = Map Int (Map Int a)

ins2d :: Int -> Int -> a -> Map2D a -> Map2D a
ins2d x y r rm = Map.alter (\m -> case m of
        Nothing -> Just $ Map.insert x r Map.empty
        Just m' -> Just $ Map.insert x r m') y rm

fmap2d :: (a->b) -> Map2D a -> Map2D b
fmap2d f = Map.map $ Map.map f

type Railmap = Map2D Rails

data Cart  = N | S | E | W
    deriving (Eq)
data Rails = None | Intn | Vert | Horz | NE | NW | SE | SW
    deriving (Eq)

data Intention = L | St | R
    deriving (Eq,Show)

next :: Intention -> Intention
next L = St
next St = R
next R = L

instance Show Track where
    show (Track railmap carts) = do
        let strMap = fmap2d show railmap
        let ins ((y,x),c,i) = ins2d x y (show c)
        let strCartMap = foldr ins strMap carts
        let str = Map.elems . Map.map (concat . Map.elems) $ strCartMap 

        unlines str

instance Show Cart where
    show N = "^"
    show S = "v"
    show E = ">"
    show W = "<"

instance Show Rails where
    show None = " "
    show Intn = "+"
    show Vert = "|"
    show Horz = "-"
    show NE   = "\\"
    show NW   = "/"
    show SE   = "/"
    show SW   = "\\"

get2d :: Int -> Int -> Map2D a -> Maybe a
get2d x y m = Map.lookup x =<< Map.lookup y m 

readTrack :: String -> Track
readTrack str = do
    let indexed = traceShowId $ zip [0..] $ map (zip [0..]) $ lines str
    let uncombine :: (a,[(b,c)]) -> [(b,a,c)]
        uncombine (a,xs) = map (\(b,c) -> (b,a,c)) xs
        !icomb = traceShowId $ concatMap uncombine indexed 
        newRailmap = foldl' f (Track Map.empty []) icomb
        f :: Track -> (Int,Int,Char) -> Track
        f (Track railmap carts) (x,y,c) = case c of
            '^' -> Track (ins2d x y Vert railmap) (((y,x),N,L):carts) 
            'v' -> Track (ins2d x y Vert railmap) (((y,x),S,L):carts) 
            '>' -> Track (ins2d x y Horz railmap) (((y,x),E,L):carts) 
            '<' -> Track (ins2d x y Horz railmap) (((y,x),W,L):carts) 
            ' ' -> Track (ins2d x y None railmap) carts
            '+' -> Track (ins2d x y Intn railmap) carts
            '|' -> Track (ins2d x y Vert railmap) carts
            '-' -> Track (ins2d x y Horz railmap) carts
            '\\' -> let dir = if get2d x (y-1) railmap == Just Vert 
                            then NE else SW
                            in Track (ins2d x y dir railmap) carts
            '/' -> let dir = if get2d x (y-1) railmap == Just Vert 
                            then NW else SE
                            in Track (ins2d x y dir railmap) carts

    newRailmap
